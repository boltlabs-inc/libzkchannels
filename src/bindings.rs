/* automatically generated by rust-bindgen */

# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EcdsaPartialSig_l { pub r : * mut :: std :: os :: raw :: c_char , pub k_inv : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_EcdsaPartialSig_l ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EcdsaPartialSig_l > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( EcdsaPartialSig_l ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EcdsaPartialSig_l > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EcdsaPartialSig_l ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EcdsaPartialSig_l > ( ) ) ) . r as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( EcdsaPartialSig_l ) , "::" , stringify ! ( r ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EcdsaPartialSig_l > ( ) ) ) . k_inv as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( EcdsaPartialSig_l ) , "::" , stringify ! ( k_inv ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HMACKey { pub key : [ :: std :: os :: raw :: c_int ; 16usize ] , } # [ test ] fn bindgen_test_layout_HMACKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HMACKey > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( HMACKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HMACKey > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( HMACKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HMACKey > ( ) ) ) . key as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HMACKey ) , "::" , stringify ! ( key ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HMACKeyCommitment { pub commitment : [ :: std :: os :: raw :: c_int ; 8usize ] , } # [ test ] fn bindgen_test_layout_HMACKeyCommitment ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HMACKeyCommitment > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( HMACKeyCommitment ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HMACKeyCommitment > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( HMACKeyCommitment ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HMACKeyCommitment > ( ) ) ) . commitment as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HMACKeyCommitment ) , "::" , stringify ! ( commitment ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HMACKeyCommitmnetOpening { pub key : * mut HMACKey , pub randomness : [ :: std :: os :: raw :: c_int ; 8usize ] , } # [ test ] fn bindgen_test_layout_HMACKeyCommitmnetOpening ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HMACKeyCommitmnetOpening > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( HMACKeyCommitmnetOpening ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HMACKeyCommitmnetOpening > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HMACKeyCommitmnetOpening ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HMACKeyCommitmnetOpening > ( ) ) ) . key as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HMACKeyCommitmnetOpening ) , "::" , stringify ! ( key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HMACKeyCommitmnetOpening > ( ) ) ) . randomness as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( HMACKeyCommitmnetOpening ) , "::" , stringify ! ( randomness ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct PayToken { pub paytoken : [ :: std :: os :: raw :: c_int ; 8usize ] , } # [ test ] fn bindgen_test_layout_PayToken ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PayToken > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( PayToken ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PayToken > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( PayToken ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PayToken > ( ) ) ) . paytoken as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( PayToken ) , "::" , stringify ! ( paytoken ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct PubKey { pub pubkey : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_PubKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PubKey > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( PubKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PubKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PubKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PubKey > ( ) ) ) . pubkey as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( PubKey ) , "::" , stringify ! ( pubkey ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RevLock { pub revlock : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_RevLock ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RevLock > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( RevLock ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RevLock > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( RevLock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RevLock > ( ) ) ) . revlock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( RevLock ) , "::" , stringify ! ( revlock ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct State { pub pkC : * mut PubKey , pub rl : * mut RevLock , pub balance_cust : :: std :: os :: raw :: c_int , pub balance_merch : :: std :: os :: raw :: c_int , pub txid_merch : [ * mut :: std :: os :: raw :: c_char ; 256usize ] , pub txid_escrow : [ * mut :: std :: os :: raw :: c_char ; 256usize ] , } # [ test ] fn bindgen_test_layout_State ( ) { assert_eq ! ( :: std :: mem :: size_of :: < State > ( ) , 4120usize , concat ! ( "Size of: " , stringify ! ( State ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < State > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( State ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < State > ( ) ) ) . pkC as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( State ) , "::" , stringify ! ( pkC ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < State > ( ) ) ) . rl as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( State ) , "::" , stringify ! ( rl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < State > ( ) ) ) . balance_cust as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( State ) , "::" , stringify ! ( balance_cust ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < State > ( ) ) ) . balance_merch as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( State ) , "::" , stringify ! ( balance_merch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < State > ( ) ) ) . txid_merch as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( State ) , "::" , stringify ! ( txid_merch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < State > ( ) ) ) . txid_escrow as * const _ as usize } , 2072usize , concat ! ( "Offset of field: " , stringify ! ( State ) , "::" , stringify ! ( txid_escrow ) ) ) ; } extern "C" { pub fn build_masked_tokens_cust ( pkM : * mut PubKey , amount : * mut :: std :: os :: raw :: c_char , com_new : * mut :: std :: os :: raw :: c_char , rl_old : * mut RevLock , port : :: std :: os :: raw :: c_int , ip_addr : * mut :: std :: os :: raw :: c_char , w_new : * mut State , w_old : * mut State , t : * mut :: std :: os :: raw :: c_char , pt_old : * mut :: std :: os :: raw :: c_char , close_tx_escrow : * mut :: std :: os :: raw :: c_char , close_tx_merch : * mut :: std :: os :: raw :: c_char , ct_masked : * mut :: std :: os :: raw :: c_char , pt_masked : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn build_masked_tokens_merch ( pkM : * mut PubKey , amount : * mut :: std :: os :: raw :: c_char , com_new : * mut :: std :: os :: raw :: c_char , rl_old : * mut RevLock , port : :: std :: os :: raw :: c_int , ip_addr : * mut :: std :: os :: raw :: c_char , close_mask : * mut :: std :: os :: raw :: c_char , pay_mask : * mut :: std :: os :: raw :: c_char , sig1 : * mut EcdsaPartialSig_l , sig2 : * mut EcdsaPartialSig_l , sig3 : * mut EcdsaPartialSig_l ) ; }